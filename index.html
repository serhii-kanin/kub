<html>
<head>
    <script src="http://cdn.rawgit.com/mrdoob/three.js/master/build/three.min.js"></script>

    <script src="./js/Box.js?3"></script>
    <script src="./js/Kube.js?3"></script>
    <script src="./js/Rotation.js"></script>

    <script src="./js/SceneRotation.js"></script>
    <script src="./js/RandomRotatonSelector.js"></script>
    <style>
        body {
            margin: 0px;
            background-color: #000000;
            color: #fff;
            font-family:Monospace;
            text-align: center;
            font-size: 15px;
            line-height: 30px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 0px; width: 100%;
            padding: 15px;
            z-index:100;
            box-sizing: border-box;
        }

        a {
            color: white;
        }
    </style>
</head>
<body>
<div id="info">
    <a href="javascript:control.setMode( 'randomize' );">Randomize</a> |
    <a href="javascript:control.setMode( 'assemble' );">Assemble</a> |
    <a href="javascript:control.stop();">Stop</a><br>
    <a href="javascript:control.rotateTop();">Rotate Top</a> |
    <a href="javascript:control.rotateITop();">Rotate ITop</a> |
    <a href="javascript:control.rotateLeft();">Rotate Left</a> |
    <a href="javascript:control.rotateILeft();">Rotate ILeft</a> |
    <a href="javascript:control.rotateRight();">Rotate Right</a> |
    <a href="javascript:control.rotateIRight();">Rotate IRight</a> |
    <a href="javascript:control.rotateBack();">Rotate Back</a> |
    <a href="javascript:control.rotateIBack();">Rotate IBack</a> |
    <a href="javascript:control.rotateFront();">Rotate Front</a> |
    <a href="javascript:control.rotateIFront();">Rotate IFront</a> |
    <a href="javascript:control.rotateBottom();">Rotate Bottom</a>
</div>
<script>
    var camera, scene, renderer;
    var boxes;
    var mouseX = 0, mouseY = 0;

    var scale = 0.11;
    var boxMargin = 0.1;
    var rotationSpeed =0.4;
    init();
    animate();

    var rotation;
    var kube;
    var rotationSelector;
    var rotationStopped = false;


    function printLog(message) {
        //console.log(message);
    }
    var control = {
        mode: 'randomize',
        setMode: function(mode) {
            rotationStopped = false;
            scene.position.z = 0;
            if (mode == 'randomize') {
                rotationSelector = new RandomRotationSelector();
            } else if (mode == 'assemble') {
                rotationSelector = new AssemblingSelector();
            }
        },
        stop: function() {
            rotationStopped = true;
        },
        rotateTop: function() { //for debug
            rotation = new Rotation('top', kube, 0.1);
        },
        rotateITop: function() { //for debug
            rotation = new Rotation('topInverse', kube, 0.1);
        },
        rotateLeft: function() { //for debug
            rotation = new Rotation('left', kube, 0.1);
        },
        rotateILeft: function() { //for debug
            rotation = new Rotation('leftInverse', kube, 0.1);
        },
        rotateRight: function() { //for debug
            rotation = new Rotation('right', kube, 0.1);
        },
        rotateIRight: function() { //for debug
            rotation = new Rotation('rightInverse', kube, 0.1);
        },
        rotateBack: function() { //for debug
            rotation = new Rotation('back', kube, 0.1);
        },
        rotateIBack: function() { //for debug
            rotation = new Rotation('backInverse', kube, 0.1);
        },
        rotateFront: function() { //for debug
            rotation = new Rotation('front', kube, 0.1);
        },
        rotateIFront: function() { //for debug
            rotation = new Rotation('frontInverse', kube, 0.1);
        },
        rotateBottom: function() { //for debug
            rotation = new Rotation('bottom', kube, 0.1);
        }
    };


    function init() {
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'mouseup', onDocumentMouseUp, false );
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
        camera.position.z = 1;

        scene = new THREE.Scene();

        boxes = [];

        kube = new Kube();
        rotationSelector = new RandomRotationSelector();


        for(var k in kube.boxes) {
            scene.add(kube.boxes[k].mesh);
        }

        scene.add(kube.selectionGroup);


        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
    }





    function resetMeshes(boxes) {
        kube.selectionGroup.children = [];
        kube.selectionGroup.rotation.x
            = kube.selectionGroup.rotation.y
            = kube.selectionGroup.rotation.z = 0;
        for(var k in kube.boxes) {
            scene.add(kube.boxes[k].mesh);
        }
    }

    function StopRotation() {
        this.rotate = function() {
            rotationStopped = true;
        }
    }


    function AssemblingSelector() {
        var step = rotationSpeed;
        var colorTop = kube.boxes['center_top_center'].color.top.getHex();
        var colorFront = kube.boxes['center_center_front'].color.front.getHex();
        var colorLeft = kube.boxes['left_center_center'].color.left.getHex();
        var colorRight = kube.boxes['right_center_center'].color.right.getHex();
        var colorBack = kube.boxes['center_center_back'].color.back.getHex();
        var colorBottom = kube.boxes['center_bottom_center'].color.bottom.getHex();


        var phase = 0;
        var scheduledRotations = [];
        var addRotations = function(storeTo, serials) {
            for(var j in serials) {
                var rotations = serials[j];
                for (var rotationName in rotations) {
                    for (var i = 0; i < rotations[rotationName]; i++) {
                        if (rotationName == 'stop') {
                            storeTo.push(new StopRotation())
                        } else {
                            storeTo.push(new Rotation(rotationName, kube, step))
                        }
                    }
                }
            }
            return storeTo;
        };

        //phase 1 vars
        //phase 1 vars
        var rightTopCornerPlaced = false;
        var rightBackTopCornerPlaced = false;
        var leftTopCornerPlaced = false;
        var leftBackTopCornerPlaced = false;


        var scheduleRotations = function() {
            var rotationsSerial = [];

            var side;
            var serial = {};
            var box;
            //phase 0 vars
            var hasBottomWithTopColor = false;


            //top christ
            if (phase == 0) {
                //printLog('phase 0');
                var boxes = kube.boxes;
                for (var k in boxes) {
                    box = boxes[k];
                    //когда на дне куба цвет верха
                    if (box.isBottomCentralRotatingWithBottomColor(colorTop)) {
                        hasBottomWithTopColor = true;
                        //printLog('bottom');
                        if (box.color.front.getHex() == colorFront) {
                            rotationsSerial = [];
                            rotationsSerial.push({front:2});
                            printLog('front rotation to top');
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.left.getHex() == colorLeft) {
                            rotationsSerial = [];
                            rotationsSerial.push({left:2});
                            printLog('left rotation to top');
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.right.getHex() == colorRight) {
                            rotationsSerial = [];
                            rotationsSerial.push({right:2});
                            printLog('right rotation to top');
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.back.getHex() == colorBack) {
                            rotationsSerial = [];
                            rotationsSerial.push({back:2});
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial);
                            printLog('back rotation to top');
                        }
                    } else if (box.isCentralRotatingWithSideColor(colorTop)) {
                        printLog('central');
                        if (box.color.front.getHex() == colorTop) {
                            rotationsSerial = [];
                            side = box.isLeft() ? 'left': 'right';
                            printLog('front-' + side);
                            serial = {};
                            serial[side] = 1;

                            serial['bottom'] = 1;
                            rotationsSerial.push(serial);
                            serial = {};
                            serial[side] = 1;
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.left.getHex() == colorTop) {
                            rotationsSerial = [];
                            side = box.isBack() ? 'back': 'front';
                            printLog('left-' + side);
                            serial = {};
                            serial[side] = 1;
                            serial['bottom'] = 1;

                            rotationsSerial.push(serial);
                            serial = {};
                            serial[side] = 1;
                            rotationsSerial.push(serial);

                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.right.getHex() == colorTop) {
                            rotationsSerial = [];
                            side = box.isBack() ? 'back': 'front';
                            printLog('right-' + side);
                            serial = {};
                            serial[side + 'Inverse'] = 1;
                            serial['bottom'] = 1;

                            rotationsSerial.push(serial);
                            serial = {};
                            serial[side] = 1;
                            rotationsSerial.push(serial);

                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        }else if (box.color.back.getHex() == colorTop) {
                            rotationsSerial = [];
                            side = box.isLeft() ? 'left': 'right';

                            printLog('back-' + side);
                            serial = {};
                            serial[side + 'Inverse'] = 1;

                            serial['bottom'] = 1;
                            //serial['stop'] = 1;
                            rotationsSerial.push(serial);
                            serial = {};
                            serial[side] = 1;
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        }
                    } else if(box.isBottomRotatingWithSideColor(colorTop)) {

                        printLog('bottom-side');
                        if (box.color.front.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'front': 1, 'stop': 0};
                            printLog('bottom-side front');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.left.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'left': 1, 'stop': 0};
                            printLog('bottom-side left');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.right.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'right': 1, 'stop': 0};
                            printLog('bottom-side right');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.back.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'back': 1, 'stop': 0};
                            printLog('bottom-side back');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        }
                    } else if(box.isTopRotatingWithSideColor(colorTop)) {
                        printLog('top-side');
                        if (box.color.front.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'front': 1, 'stop': 0};
                            printLog('top-side front');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.left.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'left': 1, 'stop': 0};
                            printLog('front-side left');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.right.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'right': 1, 'stop': 0};
                            printLog('front-side right');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.back.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'back': 1, 'stop': 0};
                            printLog('front-side back');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        }
                    }


                    if (scheduledRotations.length) {
                        printLog('break');
                        break;
                    }
                }
                if (scheduledRotations.length == 0 && hasBottomWithTopColor) {
                    printLog('rotation bottom');
                    rotationsSerial = [];
                    rotationsSerial.push({bottom:1});

                    scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                }

                if (scheduledRotations.length == 0) {
                    printLog('checking top');

                    for(var kk in boxes) {
                        box = boxes[kk];
                        if (box.isTopCentralRotatingWithTopColor(colorTop)) {
                            if (box.isLeft() && box.color.left.getHex() != colorLeft) {
                                rotationsSerial = [];
                                serial = {'left': 1, 'stop': 0};
                                rotationsSerial.push(serial);
                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            }
                            if (box.isRight() && box.color.right.getHex() != colorRight) {
                                rotationsSerial = [];
                                serial = {'right': 1, 'stop': 0};
                                rotationsSerial.push(serial);
                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            }
                            if (box.isFront() && box.color.front.getHex() != colorFront) {
                                rotationsSerial = [];
                                serial = {'front': 1, 'stop': 0};
                                rotationsSerial.push(serial);
                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            }
                            if (box.isBack() && box.color.back.getHex() != colorBack) {
                                rotationsSerial = [];
                                serial = {'back': 1, 'stop': 0};
                                rotationsSerial.push(serial);
                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            }
                        }
                        if (scheduledRotations.length) {
                            printLog('phase 1 completed');
                            break;
                        }
                    }
                    if (!scheduledRotations.length) {
                        phase = 1;
                    }
                }
            }
            //top chist corners
            else if (phase == 1) {
                //step = 0.1;

                if (!rightBackTopCornerPlaced) {
                    //сначала проверим может он уже на месте
                    box = kube.getRightTopBackCorner();
                    if (box.color.right.getHex() == colorRight &&
                        box.color.back.getHex() == colorBack &&
                        box.color.top.getHex() == colorTop
                    ) {
                        rightBackTopCornerPlaced = true;
                    } else {
                        placeTopCorner('back');
                        return;
                    }
                }
                if (!leftBackTopCornerPlaced) {
                    //step = 0.1;
                    //сначала проверим может он уже на месте
                    box = kube.getLeftTopBackCorner();
                    if (box.color.left.getHex() == colorLeft &&
                        box.color.back.getHex() == colorBack &&
                        box.color.top.getHex() == colorTop
                    ) {
                        printLog('x');
                        leftBackTopCornerPlaced = true;
                    } else {
                        placeTopCorner('left');
                        return;
                    }
                }
                if (!leftTopCornerPlaced) {
                    //сначала проверим может он уже на месте
                    box = kube.getLeftTopFrontCorner();
                    if (box.color.left.getHex() == colorLeft &&
                        box.color.front.getHex() == colorFront &&
                        box.color.top.getHex() == colorTop
                    ) {
                        leftTopCornerPlaced = true;
                    } else {
                        placeTopCorner('front');
                        return;
                    }
                }
                if (!rightTopCornerPlaced) {
                    //сначала проверим может он уже на месте
                    box = kube.getRightTopFrontCorner();
                    if (box.color.right.getHex() == colorRight &&
                        box.color.front.getHex() == colorFront &&
                        box.color.top.getHex() == colorTop
                    ) {
                        rightTopCornerPlaced = true;
                    } else {
                        placeTopCorner('right');
                        return;
                    }
                }
                if (rightBackTopCornerPlaced && leftBackTopCornerPlaced && leftTopCornerPlaced && rightTopCornerPlaced) {
                    phase = 2;
                }
                //центральный пласт
            } else if (phase == 2) {
                printLog('phase 2');
                placeCenterEdges();

                //if (phase == 3) {
                //    scheduledRotations.push(new SceneRotation());
                //}
                //крест внизу неправильный
            } else if (phase == 3) {

                //step = 0.2;
                printLog('phase 3');
                placeChristBottomIncorrect();
            }
            else if(phase == 4) {
                //step = 0.1;
                printLog('phase 4');
                placeBottomChristCorrect();
            }
            else if(phase == 5) {
                printLog('phase = 5');
                placeBottomCorners();
            } else if (phase == 6) {
                var corn = kube.getBottomCorners();
                var assembled = true;
                for(var k in corn) {
                    if (corn[k].color.bottom.getHex() != colorBottom) {
                        assembled = false;
                    }
                }
                if (assembled) {
                    phase = 7;
                }
                printLog('phase 6');
                var corner = kube.getLeftBottomFrontCorner();
                if (corner.color.bottom.getHex() == colorBottom) {
                    addRotations(scheduledRotations, [{'bottom': 1}]);
                } else {
                    addRotations(scheduledRotations, [{'leftInverse': 1, 'top': 1, 'left': 1, 'topInverse': 1}]);
                }
            } else if (phase == 7) {
                var corner = kube.getLeftBottomFrontCorner();
                if (corner.color.front.getHex() != colorFront) {
                    addRotations(scheduledRotations, [{'bottom': 1}]);
                } else {
                    if (!pressed) {
                        prevRY+=0.01;
                        prevRX+=0.01;
                        scene.position.z += 0.001 * Math.cos(prevRY);
                    }
                }
            }
        };

        var roundColors = {'front':colorFront, 'right':colorRight, 'back': colorBack, 'left':colorLeft};
        var nearBoxes = {
            'front': ['left', 'right', 'back'],
            'right': ['front', 'back', 'left'],
            'back': ['right', 'left', 'front'],
            'left': ['back', 'front', 'right']
        };

        var sideMapping = {
            'front': {
                'left': 'left',
                'right': 'right',
                'back': 'back',
                'front': 'front'
            },
            'right': {
                'left': 'front',
                'right': 'back',
                'back': 'left',
                'front': 'right'
            },
            'left': {
                'left': 'back',
                'right': 'front',
                'back': 'right',
                'front': 'left'
            },
            'back': {
                'left': 'right',
                'right': 'left',
                'back': 'front',
                'front': 'back'
            }
        };
        var moveMapping = {
            'front': {
                'left': 'left',
                'leftInverse': 'leftInverse',
                'right': 'right',
                'rightInverse': 'rightInverse',
                'back': 'back',
                'front': 'front',
                'frontInverse': 'frontInverse'
            },
            'left': {
                'left': 'back',
                'leftInverse': 'backInverse',
                'right': 'front',
                'rightInverse': 'frontInverse',
                'back': 'rightInverse',
                'front': 'leftInverse',
                'frontInverse': 'left'
            },
            'right': {
                'left': 'frontInverse',
                'leftInverse': 'front',
                'right': 'backInverse',
                'rightInverse': 'back',
                'back': 'left',
                'front': 'right',
                'frontInverse': 'rightInverse'
            },
            'back': {
                'left': 'rightInverse',
                'leftInverse': 'right',
                'right': 'leftInverse',
                'rightInverse': 'left',
                'back': 'frontInverse',
                'front': 'backInverse',
                'frontInverse': 'back'
            }
        };
        var colorMapping = {
            'front': {
                'front': 'center_center_front',
                'left': 'left_center_center',
            },
            'right': {
                'front': 'right_center_center',
                'left': 'center_center_front'
            },
            'left': {
                'front': 'left_center_center',
                'left': 'center_center_back'
            },
            'back': {
                'front': 'center_center_back',
                'left': 'right_center_center'
            }
        };

        var placeBottomCorners = function() {

            var corners = kube.getBottomCorners();

            var side;
            var corner;
            var matchCount = 0;
            for(var k in corners) {
                corner = corners[k];
                if (corner.hasColors(colorLeft, colorFront) && corner.isLeft() && corner.isFront()) {
                    console.log('front left matches');
                    side = 'front';
                    matchCount++;
                } else if(corner.hasColors(colorRight, colorFront) && corner.isRight() && corner.isFront()) {
                    console.log('front right matches');
                    side = 'right';
                    matchCount++;
                } else if(corner.hasColors(colorRight, colorBack) && corner.isRight() && corner.isBack()) {
                    console.log('right back matches');
                    side = 'back';
                    matchCount++;
                } else if(corner.hasColors(colorBack, colorLeft) && corner.isLeft() && corner.isBack()) {
                    console.log('left back matches');
                    side = 'left';
                    matchCount++;
                }
            }

            if (matchCount == 0) {
                console.log('no matches');
                bottomCornersLeftRotation('front');

                //addRotations(scheduledRotations, [{'stop': 1}]);
            } else if(matchCount == 1) {
                var leftSide = nearBoxes[side][0];
                var rightSide = nearBoxes[side][1];
                var backSide = nearBoxes[side][2];

                console.log('side left = ' + leftSide + ' right side = ' + rightSide + ' backSide = ' + backSide);
//
                for(var kk in corners) {
                    corner = corners[kk];
                    if (corner.is(leftSide) && corner.is(backSide)) {
                        console.log(side + ' color = #' + roundColors[side].toString(16) + ', '
                            + leftSide + ' color = #'+ roundColors[leftSide].toString(16) + ', '
                            + rightSide + ' color = #'+ roundColors[rightSide].toString(16) + ', '
                        );
                        if (corner.hasColors(roundColors[backSide], roundColors[rightSide])) {
                            console.log('rotation direction is from front-right to back-left');
                            bottomCornersLeftRotation(side);
                            return ;
                        }
                    }

                }

                for(var kk in corners) {
                    corner = corners[kk];
                    if (corner.is(leftSide) && corner.is(backSide)) {
                        console.log(side + ' color = #' + roundColors[side].toString(16) + ', '
                            + leftSide + ' color = #'+ roundColors[leftSide].toString(16) + ', '
                            + rightSide + ' color = #'+ roundColors[rightSide].toString(16) + ', '
                        );
                        if(corner.hasColors(roundColors[side], roundColors[rightSide])) {
                            console.log('rotation direction is from back-left to right-front');

                            bottomCornersRightRotation(side );
                            return ;
                        }

                    }

                }

            }else if (matchCount == 4) {
                console.log('all corners placed');
                phase = 6;
            }

        };

        var bottomCornersRightRotation = function(side) {
            var nearBoxes = {
                'front': 'left',
                'right': 'front',
                'back': 'right',
                'left': 'back'
            };
            side = nearBoxes[side];
            console.log('start from ' + side);
            //U' L' U R U' L U R'

            var moveLeftInverse = moveMapping[side].leftInverse;
            var moveLeft = moveMapping[side].left;
            var moveRight = moveMapping[side].right;
            var moveRightInverse = moveMapping[side].rightInverse;


            console.log('side ' + side + ' left ' + moveLeft + ' right ' + moveRight);

            var serials = [];

            var serial = {};

            serial['bottomInverse'] = 1;

            //serial['stop'] = 1;
            serial[moveRight] = 1;
            serials.push(serial);
            serial = {};
            serial['bottom'] = 1;
            serial[moveLeft] = 1;
            serials.push(serial);

            serial = {};
            serial['bottomInverse'] = 1;
            serial[moveRightInverse] = 1;
            serials.push(serial);

            serial = {};
            serial['bottom'] = 1;
            serial[moveLeftInverse] = 1;
            serials.push(serial);

            addRotations(scheduledRotations, serials);

        };

        var bottomCornersLeftRotation = function(side) {
            //U R U' L' U R' U' L

            var moveLeftInverse = moveMapping[side].leftInverse;
            var moveLeft = moveMapping[side].left;
            var moveRight = moveMapping[side].right;
            var moveRightInverse = moveMapping[side].rightInverse;


            var serials = [];

            var serial = {};

            serial['bottom'] = 1;
            serial[moveLeft] = 1;
            serial['bottomInverse'] = 1;
            serial[moveRight] = 1;
            serials.push(serial);

            serial = {};
            serial['bottom'] = 1;
            serial[moveLeftInverse] = 1;
            serials.push(serial);

            serial = {};
            serial['bottomInverse'] = 1;
            serial[moveRightInverse] = 1;
            serials.push(serial);

//console.log(serials);
//            return;
            addRotations(scheduledRotations, serials);
            //bottom
            //left
            //bottomInverse
            //rightInverse
            //bottom
            //leftInverse
            //bottom
            //right
        };

        var placeBottomChristCorrect = function() {
            var bottomEdges = kube.getBottomEdges();

            var roundEdges = {'front': null, 'right': null, 'back': null, 'left': null};

            for(var k in bottomEdges) {
                box = bottomEdges[k];
                roundEdges[box.getRoundPosition()] = box;
            }

            var leftBox;
            var rightBox;
            var oppositeBox;
            var colorToTest, leftRelativeColor, rightRelativeColor, oppositeRelativeColor;
            //проверяем если все грани заматчились то просто двигаем на низ вокруг
            for(var roundPos in roundEdges) {
                box = roundEdges[roundPos];
                leftBox = roundEdges[nearBoxes[roundPos][0]];
                rightBox = roundEdges[nearBoxes[roundPos][1]];
                oppositeBox = roundEdges[nearBoxes[roundPos][2]];
                for (var i in roundColors) {
                    colorToTest = roundColors[i];
                    leftRelativeColor = roundColors[nearBoxes[i][0]];
                    rightRelativeColor = roundColors[nearBoxes[i][1]];
                    oppositeRelativeColor = roundColors[nearBoxes[i][2]];

                    /*
                    printLog(
                        'box =' + roundPos + ';' +
                        'left = ' + nearBoxes[roundPos][0] + ';' +
                        'right = ' + nearBoxes[roundPos][1] + ';' +
                        'opposite = ' + nearBoxes[roundPos][2] + ';' +
                        'color =' + i + '; #' + colorToTest +
                        'cleftColor = ' + nearBoxes[i][0] + '; #' + leftRelativeColor.toString(16) +
                        ' rightColor = ' + nearBoxes[i][1] + '; #' + rightRelativeColor.toString(16) +
                        ' oppositeColor = ' + nearBoxes[i][2] + ';' +
                        'hasColor = ' + box.hasColor(colorToTest) + ';' +
                        'rightHasColor = ' + rightBox.hasColor(rightRelativeColor)
                    );
                    */

                    if (box.hasColor(colorToTest)
                        && leftBox.hasColor(leftRelativeColor)
                        && rightBox.hasColor(rightRelativeColor)) {
                        printLog('all colors matched');

                        //

                        if (!box.hasColor(roundColors['front'])) {
                            scheduledRotations = addRotations(scheduledRotations, [{'bottom': 1}]);

                        } else {
                            phase = 5;
                        }
                        return;
                    }


                    if (box.hasColor(colorToTest) &&
                        (
                            leftBox.hasColor(leftRelativeColor) ||
                            rightBox.hasColor(rightRelativeColor)
                        )) {
                        printLog('two near boxes with appropriate colors found');
                        if (!box.hasColor(roundColors[roundPos])) {

                            scheduledRotations = addRotations(scheduledRotations, [{'bottom': 1}]);
                        } else {
                            //вращаем сторону противоположную тестируемому кубику
                            if (leftBox.hasColor(leftRelativeColor)) {
                                var rotatingPosition = nearBoxes[leftBox.getRoundPosition()][2];
                            } else if (rightBox.hasColor(rightRelativeColor)) {
                                var rotatingPosition = nearBoxes[box.getRoundPosition()][2];
                            }
                            printLog('rotating position ' + rotatingPosition);
                            placeChristNearSidesCorrect(rotatingPosition);

                        }


                        return;
                    }

                    if (box.hasColor(colorToTest) && oppositeBox.hasColor(oppositeRelativeColor)) {
                        printLog('two opposite boxes with appropriate colors found');
                        if (!box.hasColor(roundColors[roundPos])) {

                            scheduledRotations = addRotations(scheduledRotations, [{'bottom': 1}]);
                        } else {
                            printLog('rotating position ' + leftBox.getRoundPosition());
                            placeChristOppositeSidesCorrect(leftBox.getRoundPosition());
                        }

                        return;
                    }
                }
            }
        };

        var placeChristNearSidesCorrect = function(side) {
            var moveLeftInverse = moveMapping[side].leftInverse;
            var moveLeft = moveMapping[side].left;


            var serials = [];

            var serial = {};

            serial[moveLeft] = 1;
            serial['bottom'] = 1;
            serial[moveLeftInverse] = 1;

            serials.push(serial);

            serial = {};

            serial['bottom'] = 1;
            serial[moveLeft] = 1;
            serials.push(serial);

            serial = {};

            serial['bottom'] = 2;

            serial[moveLeftInverse] = 1;
            serials.push(serial);

            serial = {};

            serial['bottom'] = 1;

            //serial['stop'] = 1;
            serials.push(serial);


            scheduledRotations = addRotations(scheduledRotations, serials);

        };

        var placeChristOppositeSidesCorrect = function(side) {
            var moveLeftInverse = moveMapping[side].leftInverse;
            var moveLeft = moveMapping[side].left;

            var serials = [];

            var serial = {};

            serial[moveLeft] = 1;
            serial['bottom'] = 1;
            serial[moveLeftInverse] = 1;

            serials.push(serial);
            serial = {};

            serial['bottom'] = 1;
            serial[moveLeft] = 1;
            serials.push(serial);
            serial = {};
            serial['bottom'] = 2;
            serial[moveLeftInverse] = 1;
            serials.push(serial);

            scheduledRotations = addRotations(scheduledRotations, serials);
        };



        var placeChristBottomIncorrect = function() {
            var bottomEdges = kube.getBottomEdges();
            var placedBottomBoxes = [];
            var box;
            for(var k in bottomEdges) {
                box = bottomEdges[k];
                if (box.color.bottom.getHex() == colorBottom) {
                    placedBottomBoxes.push(box);
                }
            }

            printLog(placedBottomBoxes.length + ' boxes placed');
            if (placedBottomBoxes.length == 0) {
                bottomChristIncorrectRotation('front');
            } else if(placedBottomBoxes.length == 2) {
                if (placedBottomBoxes[0].position.x !=0 && placedBottomBoxes[1].position.x !=0 ||
                    placedBottomBoxes[0].position.z !=0 && placedBottomBoxes[1].position.z !=0
                ) {
                    //полоска собрана
                    if (placedBottomBoxes[0].position.x !=0) {
                        printLog('side lane is placed');
                        bottomChristIncorrectRotation('front');
                    } else {
                        printLog('front lane is placed');

                        bottomChristIncorrectRotation('left');
                    }
                } else {
                    printLog('sides are placed');
                    //один в центре и один сбоку
                    if (
                        (placedBottomBoxes[0].isBack() || placedBottomBoxes[1].isBack()) &&
                        (placedBottomBoxes[0].isRight() || placedBottomBoxes[1].isRight())
                    ) {
                        bottomChristIncorrectRotation('front');
                    } else if (
                        (placedBottomBoxes[0].isFront() || placedBottomBoxes[1].isFront()) &&
                        (placedBottomBoxes[0].isRight() || placedBottomBoxes[1].isRight())
                    ) {
                        bottomChristIncorrectRotation('left');
                    } else if (
                        (placedBottomBoxes[0].isBack() || placedBottomBoxes[1].isBack()) &&
                        (placedBottomBoxes[0].isLeft() || placedBottomBoxes[1].isLeft())
                    ) {
                        bottomChristIncorrectRotation('right');
                    } else if (
                        (placedBottomBoxes[0].isFront() || placedBottomBoxes[1].isFront()) &&
                        (placedBottomBoxes[0].isLeft() || placedBottomBoxes[1].isLeft())
                    ) {
                        bottomChristIncorrectRotation('back');
                    }
                }
            } else if(placedBottomBoxes.length == 4) {
                printLog('all boxes placed');
                phase = 4;
            }

        };

        var bottomChristIncorrectRotation = function(side) {
            var moveLeftInverse = moveMapping[side].leftInverse;
            var moveLeft = moveMapping[side].left;
            var moveFrontInverse = moveMapping[side].frontInverse;
            var moveFront = moveMapping[side].front;

            var serial = {};
            serial[moveFrontInverse] = 1;
            serial[moveLeft] = 1;
            serial['bottom'] = 1;
            serial[moveLeftInverse] = 1;
            serial['bottomInverse'] = 1;
            serial[moveFront] = 1;
            //serial['stop'] = 1;
            scheduledRotations = addRotations(scheduledRotations, [serial]);
        };

        var placeCentralLeftEdge = function(side) {
            var moveLeftInverse = moveMapping[side].leftInverse;
            var moveRightInverse = moveMapping[side].rightInverse;
            var moveLeft = moveMapping[side].left;
            var moveRight = moveMapping[side].right;
            var moveFrontInverse = moveMapping[side].frontInverse;
            var moveFront = moveMapping[side].front;


            var serial = {};

            serial['bottom'] = 1;


            serial[moveLeft] = 1;
            serial['bottomInverse'] = 1;
            serial[moveLeftInverse] = 1;

            scheduledRotations = addRotations(scheduledRotations, [serial]);

            serial = {};
            serial['bottomInverse'] = 1;

            serial['stop'] = 0;
            //serial[moveFront] = 1;

            scheduledRotations = addRotations(scheduledRotations, [serial]);
            serial = {};
            serial[moveFront] = 1;
            serial['bottom'] = 1;
            serial[moveFrontInverse] = 1;
            serial['stop'] = 0;

            scheduledRotations = addRotations(scheduledRotations, [serial]);

        };

        var placeCentralRightEdge = function(side) {
            var moveLeftInverse = moveMapping[side].leftInverse;
            var moveRightInverse = moveMapping[side].rightInverse;
            var moveLeft = moveMapping[side].left;
            var moveRight = moveMapping[side].right;
            var moveFrontInverse = moveMapping[side].frontInverse;
            var moveFront = moveMapping[side].front;

            var serial = {};

            serial['bottomInverse'] = 1;


            serial[moveRight] = 1;
            serial['bottom'] = 1;
            serial[moveRightInverse] = 1;

            scheduledRotations = addRotations(scheduledRotations, [serial]);

            serial = {};
            serial['bottom'] = 1;

            serial['stop'] = 0;
            //serial[moveFront] = 1;

            scheduledRotations = addRotations(scheduledRotations, [serial]);
            serial = {};
            serial[moveFrontInverse] = 1;
            serial['bottomInverse'] = 1;
            serial[moveFront] = 1;
            serial['stop'] = 0;

            scheduledRotations = addRotations(scheduledRotations, [serial]);
        };

        var placeCenterEdges = function() {


            var edge;
            var edges = kube.getEdges();

            var colorFront = kube.boxes['center_center_front'].color.front.getHex();
            var colorBack = kube.boxes['center_center_back'].color.back.getHex();
            var colorLeft = kube.boxes['left_center_center'].color.left.getHex();
            var colorRight = kube.boxes['right_center_center'].color.right.getHex();
            var colorBottom = kube.boxes['center_bottom_center'].color.bottom.getHex();


            var destination;
            var frontColor;
            var serials = [];
            var serial;

            var round = [colorFront, colorRight, colorBack, colorLeft];
            var frontSides = ['front', 'right', 'back', 'left'];
            var roundPosition;
            var roundLeft;
            var roundRight;
            for(var k in edges) {
                edge = edges[k];
                //если есть боковушка внизу
                if (edge.isBottom() && !edge.hasColor(colorBottom)) {
                    serials = [];
                    serial = {};

                    if (edge.isRight()) {
                        destination = 3;
                        frontColor = edge.color.right.getHex();
                    } else if (edge.isBack()) {
                        destination = 2;
                        frontColor = edge.color.back.getHex();
                    } else if (edge.isLeft()) {
                        destination = 1;
                        frontColor = edge.color.left.getHex();
                    } else if (edge.isFront()) {
                        destination = 0;
                        frontColor = edge.color.front.getHex();
                    }

                    roundPosition = 0;
                    printLog('#'+frontColor.toString(16));
                    if (frontColor == colorBack) {
                        destination+=2;
                        roundPosition = 2;
                    } else if(frontColor == colorRight) {
                        destination+=1;
                        roundPosition = 1;
                    } else if(frontColor == colorLeft) {
                        destination+=3;
                        roundPosition = 3;
                    }


                    if (destination >= 4) {
                        destination-=4;
                    }
                    if (destination) {
                        serial['bottom'] = destination;
                    }


                    roundRight = roundPosition + 1;
                    if (roundRight  ==  4) {
                        roundRight = 0;
                    }
                    roundLeft = roundPosition - 1;
                    if (roundLeft == -1) {
                        roundLeft = 3;
                    }
                    printLog('roundPosition = ' + roundPosition +
                        ' roundRight = ' + roundRight +
                        ' roundLeft = ' + roundLeft +
                    ' frontSide = ' + frontSides[roundPosition]);


                    serial['stop'] = 0;
                    serials.push(serial);
                    scheduledRotations = addRotations(scheduledRotations, serials);
                    if (round[roundRight] == edge.color.bottom.getHex()) {
                        printLog('to right');
                        placeCentralRightEdge(frontSides[roundPosition]);
                    } else if(round[roundLeft] == edge.color.bottom.getHex()) {
                        printLog('to left');
                        placeCentralLeftEdge(frontSides[roundPosition]);
                    }

                }
                if (scheduledRotations.length) {
                    break;
                }
            }

            if (!scheduledRotations.length) {
                printLog('checking central edges');
                var boxes = kube.boxes;
                var box;
                printLog('checking phase 2');
                for(var k in boxes) {
                    box = boxes[k];
                    if (box.position.y == 0) {
                        if (box.isFront() && box.isLeft() && box.color.front.getHex() != colorFront) {
                            printLog('front left not matching');
                            placeCentralLeftEdge('front');
                        } else if (box.isFront() && box.isRight() && box.color.front.getHex() != colorFront) {
                            printLog('front right not matching');
                            placeCentralLeftEdge('right');
                        } else if (box.isBack() && box.isLeft() && box.color.back.getHex() != colorBack) {
                            printLog('back left not matching');
                            placeCentralLeftEdge('left');
                        } else if (box.isRight() && box.isBack() && box.color.back.getHex() != colorBack) {
                            placeCentralLeftEdge('back');
                            printLog('back right not matching');
                        }
                    }

                    if (scheduledRotations.length) {
                        break;
                    }
                }

                if (!scheduledRotations.length) {
                    phase = 3;
                }
            }
        };

        var placeTopCorner = function(side) {


            var moveLeftInverse = moveMapping[side].leftInverse;
            var moveRightInverse = moveMapping[side].rightInverse;
            var moveLeft = moveMapping[side].left;
            var moveRight = moveMapping[side].right;
            var moveFrontInverse = moveMapping[side].frontInverse;
            var moveFront = moveMapping[side].front;

            var sideLeft = sideMapping[side].left;
            var sideRight = sideMapping[side].right;
            var sideBack = sideMapping[side].back;
            var sideFront = sideMapping[side].front;

            var colorTop = kube.boxes['center_top_center'].color.top.getHex();
            var colorFront = kube.boxes[colorMapping[side].front].color[sideFront].getHex();
            var colorLeft = kube.boxes[colorMapping[side].left].color[sideLeft].getHex();

            var rotationsSerial;
            var corners = kube.getCorners();
            var corner;
            var serial;
            for(var c in corners) {
                corner = corners[c];
                if (corner.hasColors(colorTop, colorFront, colorLeft)) {
                    printLog('left top front corner position ' +
                        'x = ' + corner.position.x + ', ' +
                        'y = ' + corner.position.y + ', ' +
                        'z = ' + corner.position.z
                    );
                    //если он вверху
                    if (corner.isTop()) {
                        if (corner.is(sideLeft) && corner.is(sideBack)) {
                            printLog(1);
                            rotationsSerial = [];
                            serial = {};
                            serial[moveLeftInverse] = 1; serial['bottom'] = 1; serial[moveLeft] = 1;
                            serial['stop'] = 0;
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (corner.is(sideLeft) && corner.is(sideFront)) {
                            printLog(2);
                            rotationsSerial = [];
                            serial = {};
                            serial[moveLeft] = 1; serial['bottomInverse'] = 1; serial[moveLeftInverse] = 1;
                            serial['stop'] = 0;
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if(corner.is(sideRight) && corner.is(sideBack)) {
                            printLog(3);
                            rotationsSerial = [];
                            serial = {};
                            serial[moveRightInverse] = 1; serial['bottom'] = 1; serial[moveRight] = 1;
                            serial['stop'] = 0;
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if(corner.is(sideRight) && corner.is(sideFront)) {
                            printLog(4);
                            rotationsSerial = [];
                            serial = {};
                            serial[moveRight] = 1; serial['bottomInverse'] = 1; serial[moveRightInverse] = 1;
                            serial['stop'] = 0;
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        }
                    } else if(corner.isBottom()) {
                        if (corner.is(sideLeft) && corner.is(sideBack)) {
                            printLog(5);
                            rotationsSerial = [];
                            rotationsSerial.push({bottom: 1, stop: 0});
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if(corner.is(sideRight) && corner.is(sideBack)) {
                            printLog(6);
                            rotationsSerial = [];
                            rotationsSerial.push({bottom: 2, stop: 0});
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if(corner.is(sideRight) && corner.is(sideFront)) {
                            printLog(7);
                            rotationsSerial = [];
                            rotationsSerial.push({bottomInverse: 1, stop: 0});
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (corner.is(sideLeft) && corner.is(sideFront)) {
                            //кубик снизу под нужным местом и повернут вниз нужной гранью
                            //и фронт цвет равен цвету слева
                            if (corner.color.bottom.getHex() == colorTop &&
                                corner.color[sideFront].getHex() == colorLeft) {
                                printLog(8);
                                rotationsSerial = [];

                                serial = {};
                                serial[moveLeft] = 1; serial['bottomInverse'] = 1; serial[moveLeftInverse] = 1;

                                rotationsSerial.push(serial);
                                serial = {};
                                serial['bottom'] = 1; serial[moveFront] = 1;
                                rotationsSerial.push(serial);

                                serial = {};
                                serial['bottom'] = 1; serial[moveFrontInverse] = 1;
                                serial['stop'] = 0;
                                rotationsSerial.push(serial);
                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            } else if (corner.color[sideFront].getHex() == colorTop) {
                                printLog(9);
                                rotationsSerial = [];
                                serial = {};
                                serial['bottom'] = 1; serial[moveLeft] = 1;

                                rotationsSerial.push(serial);

                                serial = {};
                                serial['bottomInverse'] = 1; serial[moveLeftInverse] = 1;
                                serial['stop'] = 0;
                                rotationsSerial.push(serial);

                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            } else if (corner.color[sideLeft].getHex() == colorTop) {
                                printLog(10);
                                rotationsSerial = [];
                                serial = {};
                                serial['bottomInverse'] = 1; serial[moveFront] = 1;
                                rotationsSerial.push(serial);
                                serial = {};
                                serial['bottom'] = 1; serial[moveFrontInverse] = 1;
                                serial['stop'] = 0;
                                rotationsSerial.push(serial);

                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            }
                        }
                    }

                }
                if (scheduledRotations.length) {
                    break;
                }
            }
        };


        /**
         * box.color.back.setHex(0x000000);
         box.color.front.setHex(0x000000);
         box.color.left.setHex(0x000000);
         box.color.right.setHex(0x000000);
         box.color.top.setHex(0x000000);
         box.color.bottom.setHex(0x000000);
         box.mesh.geometry.colorsNeedUpdate = true;
         */



        this.getNextRotation = function() {
            //printLog(scheduledRotations);
            if (scheduledRotations.length) {

                return scheduledRotations.shift();
            } else {
                scheduleRotations();
            }
            return null;
        };

        return this;

    }


    /*

    */

    function animate() {
        requestAnimationFrame( animate );

        if (!rotationStopped && (!rotation || rotation.isFinished)) {
            rotation = rotationSelector.getNextRotation();
        } else {
            rotation && rotation.rotate();
        }

        scene.rotation.y = prevRY + mouseX / 100;
        scene.rotation.x = prevRX + mouseY / 100;

        renderer.render( scene, camera );

    }

    var initX, initY;
    var prevRX = 0, prevRY = 0;
    var pressed = false;
    function onDocumentMouseMove( event ) {
        if (pressed) {
            mouseX = (event.clientX - initX);
            mouseY = (event.clientY - initY);
        }
    }
    function onDocumentMouseUp( event ) {
        pressed = false;
    }
    function onDocumentMouseDown( event ) {
        initX = event.clientX;
        initY = event.clientY;
        prevRX = scene.rotation.x;
        prevRY = scene.rotation.y;
        mouseX = 0;
        mouseY = 0;
        pressed = true;
    }
</script>
</body>
</html>