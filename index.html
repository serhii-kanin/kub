<html>
<head>
    <script src="//cdn.rawgit.com/mrdoob/three.js/master/build/three.min.js"></script>

    <script src="./js/Box.js"></script>
    <script src="./js/Kube.js"></script>
    <script src="./js/Rotation.js"></script>
    <script src="./js/RandomRotatonSelector.js"></script>
    <style>
        body {
            margin: 0px;
            background-color: #000000;
            color: #fff;
            font-family:Monospace;
            text-align: center;
            font-size: 15px;
            line-height: 30px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 0px; width: 100%;
            padding: 15px;
            z-index:100;
            box-sizing: border-box;
        }

        a {
            color: white;
        }
    </style>
</head>
<body>
<div id="info">
    <a href="javascript:control.setMode( 'randomize' );">Randomize</a> |
    <a href="javascript:control.setMode( 'assemble' );">Assemble</a> |
    <a href="javascript:control.stop();">Stop</a><br>
    <a href="javascript:control.rotateTop();">Rotate Top</a> |
    <a href="javascript:control.rotateITop();">Rotate ITop</a> |
    <a href="javascript:control.rotateLeft();">Rotate Left</a> |
    <a href="javascript:control.rotateILeft();">Rotate ILeft</a> |
    <a href="javascript:control.rotateRight();">Rotate Right</a> |
    <a href="javascript:control.rotateIRight();">Rotate IRight</a> |
    <a href="javascript:control.rotateBack();">Rotate Back</a> |
    <a href="javascript:control.rotateIBack();">Rotate IBack</a> |
    <a href="javascript:control.rotateFront();">Rotate Front</a> |
    <a href="javascript:control.rotateIFront();">Rotate IFront</a> |
    <a href="javascript:control.rotateBottom();">Rotate Bottom</a>
</div>
<script>
    var camera, scene, renderer;
    var boxes;
    var mouseX = 0, mouseY = 0;

    var scale = 0.11;
    var rotationSpeed =0.2;
    init();
    animate();

    var rotation;
    var kube;
    var rotationSelector;
    var rotationStopped = false;

    var control = {
        mode: 'randomize',
        setMode: function(mode) {
            rotationStopped = false;
            if (mode == 'randomize') {
                rotationSelector = new RandomRotationSelector();
            } else if (mode == 'assemble') {
                rotationSelector = new AssemblingSelector();
            }
        },
        stop: function() {
            rotationStopped = true;
        },
        rotateTop: function() { //for debug
            rotation = new Rotation('top', kube, 0.1);
        },
        rotateITop: function() { //for debug
            rotation = new Rotation('topInverse', kube, 0.1);
        },
        rotateLeft: function() { //for debug
            rotation = new Rotation('left', kube, 0.1);
        },
        rotateILeft: function() { //for debug
            rotation = new Rotation('leftInverse', kube, 0.1);
        },
        rotateRight: function() { //for debug
            rotation = new Rotation('right', kube, 0.1);
        },
        rotateIRight: function() { //for debug
            rotation = new Rotation('rightInverse', kube, 0.1);
        },
        rotateBack: function() { //for debug
            rotation = new Rotation('back', kube, 0.1);
        },
        rotateIBack: function() { //for debug
            rotation = new Rotation('backInverse', kube, 0.1);
        },
        rotateFront: function() { //for debug
            rotation = new Rotation('front', kube, 0.1);
        },
        rotateIFront: function() { //for debug
            rotation = new Rotation('frontInverse', kube, 0.1);
        },
        rotateBottom: function() { //for debug
            rotation = new Rotation('bottom', kube, 0.1);
        }
    };


    function init() {
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'mouseup', onDocumentMouseUp, false );
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
        camera.position.z = 1;

        scene = new THREE.Scene();

        boxes = [];

        kube = new Kube();
        rotationSelector = new RandomRotationSelector();


        for(var k in kube.boxes) {
            scene.add(kube.boxes[k].mesh);
        }

        scene.add(kube.selectionGroup);


        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
    }





    function resetMeshes(boxes) {
        kube.selectionGroup.children = [];
        kube.selectionGroup.rotation.x
            = kube.selectionGroup.rotation.y
            = kube.selectionGroup.rotation.z = 0;
        for(var k in kube.boxes) {
            scene.add(kube.boxes[k].mesh);
        }
    }

    function StopRotation() {
        this.rotate = function() {
            rotationStopped = true;
        }
    }


    function AssemblingSelector() {
        var step = rotationSpeed;
        var colorTop = kube.boxes['center_top_center'].color.top.getHex();
        var colorFront = kube.boxes['center_center_front'].color.front.getHex();
        var colorLeft = kube.boxes['left_center_center'].color.left.getHex();
        var colorRight = kube.boxes['right_center_center'].color.right.getHex();
        var colorBack = kube.boxes['center_center_back'].color.back.getHex();


        var phase = 0;
        var scheduledRotations = [];
        var addRotations = function(storeTo, serials) {
            for(var j in serials) {
                var rotations = serials[j];
                for (var rotationName in rotations) {
                    for (var i = 0; i < rotations[rotationName]; i++) {
                        if (rotationName == 'stop') {
                            storeTo.push(new StopRotation())
                        } else {
                            storeTo.push(new Rotation(rotationName, kube, step))
                        }
                    }
                }
            }
            return storeTo;
        };

        //phase 1 vars
        //phase 1 vars
        var rightTopCornerPlaced = false;
        var rightBackTopCornerPlaced = false;
        var leftTopCornerPlaced = false;
        var leftBackTopCornerPlaced = false;


        var scheduleRotations = function() {
            var rotationsSerial = [];

            var side;
            var serial = {};
            var box;
            //phase 0 vars
            var hasBottomWithTopColor = false;


            //top christ
            if (phase == 0) {
                //console.log('phase 0');
                var boxes = kube.boxes;
                for (var k in boxes) {
                    box = boxes[k];
                    //когда на дне куба цвет верха
                    if (box.isBottomCentralRotatingWithBottomColor(colorTop)) {
                        hasBottomWithTopColor = true;
                        //console.log('bottom');
                        if (box.color.front.getHex() == colorFront) {
                            rotationsSerial = [];
                            rotationsSerial.push({front:2});
                            console.log('front rotation to top');
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.left.getHex() == colorLeft) {
                            rotationsSerial = [];
                            rotationsSerial.push({left:2});
                            console.log('left rotation to top');
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.right.getHex() == colorRight) {
                            rotationsSerial = [];
                            rotationsSerial.push({right:2});
                            console.log('right rotation to top');
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.back.getHex() == colorBack) {
                            rotationsSerial = [];
                            rotationsSerial.push({back:2});
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial);
                            console.log('back rotation to top');
                        }
                    } else if (box.isCentralRotatingWithSideColor(colorTop)) {
                        console.log('central');
                        if (box.color.front.getHex() == colorTop) {
                            rotationsSerial = [];
                            side = box.isLeft() ? 'left': 'right';
                            console.log('front-' + side);
                            serial = {};
                            serial[side] = 1;

                            serial['bottom'] = 1;
                            rotationsSerial.push(serial);
                            serial = {};
                            serial[side] = 1;
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.left.getHex() == colorTop) {
                            rotationsSerial = [];
                            side = box.isBack() ? 'back': 'front';
                            console.log('left-' + side);
                            serial = {};
                            serial[side] = 1;
                            serial['bottom'] = 1;

                            rotationsSerial.push(serial);
                            serial = {};
                            serial[side] = 1;
                            rotationsSerial.push(serial);

                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.right.getHex() == colorTop) {
                            rotationsSerial = [];
                            side = box.isBack() ? 'back': 'front';
                            console.log('right-' + side);
                            serial = {};
                            serial[side] = 3;
                            serial['bottom'] = 1;

                            rotationsSerial.push(serial);
                            serial = {};
                            serial[side] = 1;
                            rotationsSerial.push(serial);

                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        }else if (box.color.back.getHex() == colorTop) {
                            rotationsSerial = [];
                            side = box.isLeft() ? 'left': 'right';

                            console.log('back-' + side);
                            serial = {};
                            serial[side] = 3;

                            serial['bottom'] = 1;
                            //serial['stop'] = 1;
                            rotationsSerial.push(serial);
                            serial = {};
                            serial[side] = 1;
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        }
                    } else if(box.isBottomRotatingWithSideColor(colorTop)) {

                        console.log('bottom-side');
                        if (box.color.front.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'front': 1, 'stop': 0};
                            console.log('bottom-side front');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.left.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'left': 1, 'stop': 0};
                            console.log('bottom-side left');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.right.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'right': 1, 'stop': 0};
                            console.log('bottom-side right');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.back.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'back': 1, 'stop': 0};
                            console.log('bottom-side back');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        }
                    } else if(box.isTopRotatingWithSideColor(colorTop)) {
                        console.log('top-side');
                        if (box.color.front.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'front': 1, 'stop': 0};
                            console.log('top-side front');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.left.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'left': 1, 'stop': 0};
                            console.log('front-side left');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.right.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'right': 1, 'stop': 0};
                            console.log('front-side right');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (box.color.back.getHex() == colorTop) {
                            rotationsSerial = [];
                            serial = {'back': 1, 'stop': 0};
                            console.log('front-side back');
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        }
                    }


                    if (scheduledRotations.length) {
                        console.log('break');
                        break;
                    }
                }
                if (scheduledRotations.length == 0 && hasBottomWithTopColor) {
                    console.log('rotation bottom');
                    rotationsSerial = [];
                    rotationsSerial.push({bottom:1});

                    scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                }

                if (scheduledRotations.length == 0) {
                    console.log('checking top');

                    for(var kk in boxes) {
                        box = boxes[kk];
                        if (box.isTopCentralRotatingWithTopColor(colorTop)) {
                            if (box.isLeft() && box.color.left.getHex() != colorLeft) {
                                rotationsSerial = [];
                                serial = {'left': 1, 'stop': 0};
                                rotationsSerial.push(serial);
                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            }
                            if (box.isRight() && box.color.right.getHex() != colorRight) {
                                rotationsSerial = [];
                                serial = {'right': 1, 'stop': 0};
                                rotationsSerial.push(serial);
                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            }
                            if (box.isFront() && box.color.front.getHex() != colorFront) {
                                rotationsSerial = [];
                                serial = {'front': 1, 'stop': 0};
                                rotationsSerial.push(serial);
                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            }
                            if (box.isBack() && box.color.back.getHex() != colorBack) {
                                rotationsSerial = [];
                                serial = {'back': 1, 'stop': 0};
                                rotationsSerial.push(serial);
                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            }
                        }
                        if (scheduledRotations.length) {
                            console.log('phase 1 completed');
                            break;
                        }
                    }
                    if (!scheduledRotations.length) {
                        phase = 1;
                    }
                }
            }
            //top chist corners
            else if (phase == 1) {
                //step = 0.1;

                if (!rightBackTopCornerPlaced) {
                    //сначала проверим может он уже на месте
                    box = kube.getRightTopBackCorner();
                    if (box.color.right.getHex() == colorRight &&
                        box.color.back.getHex() == colorBack &&
                        box.color.top.getHex() == colorTop
                    ) {
                        rightBackTopCornerPlaced = true;
                    } else {
                        placeTopCorner('back');
                        return;
                    }
                }
                if (!leftBackTopCornerPlaced) {
                    //step = 0.1;
                    //сначала проверим может он уже на месте
                    box = kube.getLeftTopBackCorner();
                    if (box.color.left.getHex() == colorLeft &&
                        box.color.back.getHex() == colorBack &&
                        box.color.top.getHex() == colorTop
                    ) {
                        console.log('x');
                        leftBackTopCornerPlaced = true;
                    } else {
                        placeTopCorner('left');
                        return;
                    }
                }
                if (!leftTopCornerPlaced) {
                    //сначала проверим может он уже на месте
                    box = kube.getLeftTopFrontCorner();
                    if (box.color.left.getHex() == colorLeft &&
                        box.color.front.getHex() == colorFront &&
                        box.color.top.getHex() == colorTop
                    ) {
                        leftTopCornerPlaced = true;
                    } else {
                        placeTopCorner('front');
                        return;
                    }
                }
                if (!rightTopCornerPlaced) {
                    //сначала проверим может он уже на месте
                    box = kube.getRightTopFrontCorner();
                    if (box.color.right.getHex() == colorRight &&
                        box.color.front.getHex() == colorFront &&
                        box.color.top.getHex() == colorTop
                    ) {
                        rightTopCornerPlaced = true;
                    } else {
                        placeTopCorner('right');
                        return;
                    }
                }
                if (rightBackTopCornerPlaced && leftBackTopCornerPlaced && leftTopCornerPlaced && rightTopCornerPlaced) {
                    phase = 2;
                }
            } else if (phase == 2) {
                console.log('phase 2');

                placeCenterEdges();
            }
        };

        var sideMapping = {
            'front': {
                'left': 'left',
                'right': 'right',
                'back': 'back',
                'front': 'front'
            },
            'right': {
                'left': 'front',
                'right': 'back',
                'back': 'left',
                'front': 'right'
            },
            'left': {
                'left': 'back',
                'right': 'front',
                'back': 'right',
                'front': 'left'
            },
            'back': {
                'left': 'right',
                'right': 'left',
                'back': 'front',
                'front': 'back'
            }
        };
        var moveMapping = {
            'front': {
                'left': 'left',
                'leftInverse': 'leftInverse',
                'right': 'right',
                'rightInverse': 'rightInverse',
                'back': 'back',
                'front': 'front',
                'frontInverse': 'frontInverse'
            },
            'left': {
                'left': 'back',
                'leftInverse': 'backInverse',
                'right': 'front',
                'rightInverse': 'frontInverse',
                'back': 'rightInverse',
                'front': 'leftInverse',
                'frontInverse': 'left'
            },
            'right': {
                'left': 'frontInverse',
                'leftInverse': 'front',
                'right': 'backInverse',
                'rightInverse': 'back',
                'back': 'left',
                'front': 'right',
                'frontInverse': 'rightInverse'
            },
            'back': {
                'left': 'rightInverse',
                'leftInverse': 'right',
                'right': 'leftInverse',
                'rightInverse': 'left',
                'back': 'frontInverse',
                'front': 'backInverse',
                'frontInverse': 'back'
            }
        };
        var colorMapping = {
            'front': {
                'front': 'center_center_front',
                'left': 'left_center_center',
            },
            'right': {
                'front': 'right_center_center',
                'left': 'center_center_front'
            },
            'left': {
                'front': 'left_center_center',
                'left': 'center_center_back'
            },
            'back': {
                'front': 'center_center_back',
                'left': 'right_center_center'
            }
        };

        var placeCentralLeftEdge = function(side) {
            var moveLeftInverse = moveMapping[side].leftInverse;
            var moveRightInverse = moveMapping[side].rightInverse;
            var moveLeft = moveMapping[side].left;
            var moveRight = moveMapping[side].right;
            var moveFrontInverse = moveMapping[side].frontInverse;
            var moveFront = moveMapping[side].front;


            var serial = {};

            serial['bottom'] = 1;


            serial[moveLeft] = 1;
            serial['bottomInverse'] = 1;
            serial[moveLeftInverse] = 1;

            scheduledRotations = addRotations(scheduledRotations, [serial]);

            serial = {};
            serial['bottomInverse'] = 1;

            serial['stop'] = 0;
            //serial[moveFront] = 1;

            scheduledRotations = addRotations(scheduledRotations, [serial]);
            serial = {};
            serial[moveFront] = 1;
            serial['bottom'] = 1;
            serial[moveFrontInverse] = 1;
            serial['stop'] = 0;

            scheduledRotations = addRotations(scheduledRotations, [serial]);

        };
        var placeCentralRightEdge = function(side) {
            var moveLeftInverse = moveMapping[side].leftInverse;
            var moveRightInverse = moveMapping[side].rightInverse;
            var moveLeft = moveMapping[side].left;
            var moveRight = moveMapping[side].right;
            var moveFrontInverse = moveMapping[side].frontInverse;
            var moveFront = moveMapping[side].front;

            var serial = {};

            serial['bottomInverse'] = 1;


            serial[moveRight] = 1;
            serial['bottom'] = 1;
            serial[moveRightInverse] = 1;

            scheduledRotations = addRotations(scheduledRotations, [serial]);

            serial = {};
            serial['bottom'] = 1;

            serial['stop'] = 0;
            //serial[moveFront] = 1;

            scheduledRotations = addRotations(scheduledRotations, [serial]);
            serial = {};
            serial[moveFrontInverse] = 1;
            serial['bottomInverse'] = 1;
            serial[moveFront] = 1;
            serial['stop'] = 0;

            scheduledRotations = addRotations(scheduledRotations, [serial]);
        };

        var placeCenterEdges = function() {


            var edge;
            var edges = kube.getEdges();

            var colorFront = kube.boxes['center_center_front'].color.front.getHex();
            var colorBack = kube.boxes['center_center_back'].color.back.getHex();
            var colorLeft = kube.boxes['left_center_center'].color.left.getHex();
            var colorRight = kube.boxes['right_center_center'].color.right.getHex();
            var colorBottom = kube.boxes['center_bottom_center'].color.bottom.getHex();


            var destination;
            var frontColor;
            var serials = [];
            var serial;

            var round = [colorFront, colorRight, colorBack, colorLeft];
            var frontSides = ['front', 'right', 'back', 'left'];
            var roundPosition;
            var roundLeft;
            var roundRight;
            for(var k in edges) {
                edge = edges[k];
                //если есть боковушка внизу
                if (edge.isBottom() && !edge.hasColor(colorBottom)) {
                    serials = [];
                    serial = {};

                    if (edge.isRight()) {
                        destination = 3;
                        frontColor = edge.color.right.getHex();
                    } else if (edge.isBack()) {
                        destination = 2;
                        frontColor = edge.color.back.getHex();
                    } else if (edge.isLeft()) {
                        destination = 1;
                        frontColor = edge.color.left.getHex();
                    } else if (edge.isFront()) {
                        destination = 0;
                        frontColor = edge.color.front.getHex();
                    }

                    roundPosition = 0;
                    console.log('#'+frontColor.toString(16));
                    if (frontColor == colorBack) {
                        destination+=2;
                        roundPosition = 2;
                    } else if(frontColor == colorRight) {
                        destination+=1;
                        roundPosition = 1;
                    } else if(frontColor == colorLeft) {
                        destination+=3;
                        roundPosition = 3;
                    }


                    if (destination >= 4) {
                        destination-=4;
                    }
                    if (destination) {
                        serial['bottom'] = destination;
                    }


                    roundRight = roundPosition + 1;
                    if (roundRight  ==  4) {
                        roundRight = 0;
                    }
                    roundLeft = roundPosition - 1;
                    if (roundLeft == -1) {
                        roundLeft = 3;
                    }
                    console.log('roundPosition = ' + roundPosition +
                        ' roundRight = ' + roundRight +
                        ' roundLeft = ' + roundLeft +
                    ' frontSide = ' + frontSides[roundPosition]);


                    serial['stop'] = 0;
                    serials.push(serial);
                    scheduledRotations = addRotations(scheduledRotations, serials);
                    if (round[roundRight] == edge.color.bottom.getHex()) {
                        console.log('to right');
                        placeCentralRightEdge(frontSides[roundPosition]);
                    } else if(round[roundLeft] == edge.color.bottom.getHex()) {
                        console.log('to left');
                        placeCentralLeftEdge(frontSides[roundPosition]);
                    }

                }
                if (scheduledRotations.length) {
                    break;
                }
            }

            if (!scheduledRotations.length) {
                console.log('checking central edges');
                var boxes = kube.boxes;
                var box;
                console.log('checking phase 2');
                for(var k in boxes) {
                    box = boxes[k];
                    if (box.position.y == 0) {
                        if (box.isFront() && box.isLeft() && box.color.front.getHex() != colorFront) {
                            console.log('front left not matching');
                            placeCentralLeftEdge('front');
                        } else if (box.isFront() && box.isRight() && box.color.front.getHex() != colorFront) {
                            console.log('front right not matching');
                            placeCentralLeftEdge('right');
                        } else if (box.isBack() && box.isLeft() && box.color.back.getHex() != colorBack) {
                            console.log('back left not matching');
                            placeCentralLeftEdge('left');
                        } else if (box.isRight() && box.isBack() && box.color.back.getHex() != colorBack) {
                            placeCentralLeftEdge('back');
                            console.log('back right not matching');
                        }
                    }

                    if (scheduledRotations.length) {
                        break;
                    }
                }

                if (!scheduledRotations.length) {
                    phase = 3;
                }
            }
        };

        var placeTopCorner = function(side) {


            var moveLeftInverse = moveMapping[side].leftInverse;
            var moveRightInverse = moveMapping[side].rightInverse;
            var moveLeft = moveMapping[side].left;
            var moveRight = moveMapping[side].right;
            var moveFrontInverse = moveMapping[side].frontInverse;
            var moveFront = moveMapping[side].front;

            var sideLeft = sideMapping[side].left;
            var sideRight = sideMapping[side].right;
            var sideBack = sideMapping[side].back;
            var sideFront = sideMapping[side].front;

            var colorTop = kube.boxes['center_top_center'].color.top.getHex();
            var colorFront = kube.boxes[colorMapping[side].front].color[sideFront].getHex();
            var colorLeft = kube.boxes[colorMapping[side].left].color[sideLeft].getHex();

            var rotationsSerial;
            var corners = kube.getCorners();
            var corner;
            var serial;
            for(var c in corners) {
                corner = corners[c];
                if (corner.hasColors(colorTop, colorFront, colorLeft)) {
                    console.log('left top front corner position ' +
                        'x = ' + corner.position.x + ', ' +
                        'y = ' + corner.position.y + ', ' +
                        'z = ' + corner.position.z
                    );
                    //если он вверху
                    if (corner.isTop()) {
                        if (corner.is(sideLeft) && corner.is(sideBack)) {
                            console.log(1);
                            rotationsSerial = [];
                            serial = {};
                            serial[moveLeftInverse] = 1; serial['bottom'] = 1; serial[moveLeft] = 1;
                            serial['stop'] = 0;
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (corner.is(sideLeft) && corner.is(sideFront)) {
                            console.log(2);
                            rotationsSerial = [];
                            serial = {};
                            serial[moveLeft] = 1; serial['bottomInverse'] = 1; serial[moveLeftInverse] = 1;
                            serial['stop'] = 0;
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if(corner.is(sideRight) && corner.is(sideBack)) {
                            console.log(3);
                            rotationsSerial = [];
                            serial = {};
                            serial[moveRightInverse] = 1; serial['bottom'] = 1; serial[moveRight] = 1;
                            serial['stop'] = 0;
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if(corner.is(sideRight) && corner.is(sideFront)) {
                            console.log(4);
                            rotationsSerial = [];
                            serial = {};
                            serial[moveRight] = 1; serial['bottomInverse'] = 1; serial[moveRightInverse] = 1;
                            serial['stop'] = 0;
                            rotationsSerial.push(serial);
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        }
                    } else if(corner.isBottom()) {
                        if (corner.is(sideLeft) && corner.is(sideBack)) {
                            console.log(5);
                            rotationsSerial = [];
                            rotationsSerial.push({bottom: 1, stop: 0});
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if(corner.is(sideRight) && corner.is(sideBack)) {
                            console.log(6);
                            rotationsSerial = [];
                            rotationsSerial.push({bottom: 2, stop: 0});
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if(corner.is(sideRight) && corner.is(sideFront)) {
                            console.log(7);
                            rotationsSerial = [];
                            rotationsSerial.push({bottomInverse: 1, stop: 0});
                            scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                        } else if (corner.is(sideLeft) && corner.is(sideFront)) {
                            //кубик снизу под нужным местом и повернут вниз нужной гранью
                            //и фронт цвет равен цвету слева
                            if (corner.color.bottom.getHex() == colorTop &&
                                corner.color[sideFront].getHex() == colorLeft) {
                                console.log(8);
                                rotationsSerial = [];

                                serial = {};
                                serial[moveLeft] = 1; serial['bottomInverse'] = 1; serial[moveLeftInverse] = 1;

                                rotationsSerial.push(serial);
                                serial = {};
                                serial['bottom'] = 1; serial[moveFront] = 1;
                                rotationsSerial.push(serial);

                                serial = {};
                                serial['bottom'] = 1; serial[moveFrontInverse] = 1;
                                serial['stop'] = 0;
                                rotationsSerial.push(serial);
                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            } else if (corner.color[sideFront].getHex() == colorTop) {
                                console.log(9);
                                rotationsSerial = [];
                                serial = {};
                                serial['bottom'] = 1; serial[moveLeft] = 1;

                                rotationsSerial.push(serial);

                                serial = {};
                                serial['bottomInverse'] = 1; serial[moveLeftInverse] = 1;
                                serial['stop'] = 0;
                                rotationsSerial.push(serial);

                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            } else if (corner.color[sideLeft].getHex() == colorTop) {
                                console.log(10);
                                rotationsSerial = [];
                                serial = {};
                                serial['bottomInverse'] = 1; serial[moveFront] = 1;
                                rotationsSerial.push(serial);
                                serial = {};
                                serial['bottom'] = 1; serial[moveFrontInverse] = 1;
                                serial['stop'] = 0;
                                rotationsSerial.push(serial);

                                scheduledRotations = addRotations(scheduledRotations, rotationsSerial)
                            }
                        }
                    }

                }
                if (scheduledRotations.length) {
                    break;
                }
            }
        };

        /**
         * box.color.back.setHex(0x000000);
         box.color.front.setHex(0x000000);
         box.color.left.setHex(0x000000);
         box.color.right.setHex(0x000000);
         box.color.top.setHex(0x000000);
         box.color.bottom.setHex(0x000000);
         box.mesh.geometry.colorsNeedUpdate = true;
         */



        this.getNextRotation = function() {
            //console.log(scheduledRotations);
            if (scheduledRotations.length) {

                return scheduledRotations.shift();
            } else {
                scheduleRotations();
            }
            return null;
        };

        return this;

    }


    /*

    */

    function animate() {
        requestAnimationFrame( animate );

        if (!rotationStopped && (!rotation || rotation.isFinished)) {
            rotation = rotationSelector.getNextRotation();
        } else {
            rotation && rotation.rotate();
        }

        scene.rotation.y = prevRY + mouseX / 100;
        scene.rotation.x = prevRX + mouseY / 100;

        renderer.render( scene, camera );

    }

    var initX, initY;
    var prevRX = 0, prevRY = 0;
    var pressed = false;
    function onDocumentMouseMove( event ) {
        if (pressed) {
            mouseX = (event.clientX - initX);
            mouseY = (event.clientY - initY);
        }
    }
    function onDocumentMouseUp( event ) {
        pressed = false;
    }
    function onDocumentMouseDown( event ) {
        initX = event.clientX;
        initY = event.clientY;
        prevRX = scene.rotation.x;
        prevRY = scene.rotation.y;
        mouseX = 0;
        mouseY = 0;
        pressed = true;
    }
</script>
</body>
</html>